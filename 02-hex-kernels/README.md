# Understanding Kernel Formats

We need to get code into the correct location to run it, and we need QEMU to be able to understand the format we provide it!

## Aims

- Understand what format we need to make a kernel bootable in QEMU
- Know which parts of an ELF file are important for our purposes and which are not needed.
- Create a reasonably minimal ELF file which can be re-used for our future hex programs
- Understand what parts of that ELF file will need to change per-program

## Kernel File Formats

So far we've used an ELF file to provide the kernel for QEMU, and in fact that's the only choice we have as evidenced by the `riscv-qemu` source code for [load\_kernel](https://github.com/riscv/riscv-qemu/blob/32a1a94dd324d33578dca1dc96d7896a0244d768/hw/riscv/sifive_e.c#L77-L88)[1].

That means that to run under QEMU, we always have to provide an [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) file[2].

That introduces a decent amount of complexity in our build process that it would be desirable to avoid; it's harder to generate an ELF than a raw binary file. But we can make a simple ELF header in hex and then `cat` the header along with our code.

## ELF Files

The [Wikipedia](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header) article on ELF files is an excellent reference for the format. The following is a brief overview of the different sections, but more in-depth analysis is provided in [ELF\_DETAIL](../guides/ELF_DETAIL.md).

We don't need that level of detail - we can treat the ELF header as a black box most of the time. There are only a few parts which we need to change.

First, the ELF file needs to reflect the total size of the program. Second, it needs to point to the location in memory that the kernel should be loaded. Mostly, that's all we need to tweak! [3]

If stripped down, there really isn't much more that needs to change. We explicitly lay out the header such that there's very little which varies. ELF files have multiple sections, and we want to use only a bare minimum:

- a "null" section which seems to be required - this is just blank
- `.text` contains our code
- `.shstrtab` which has header names for everything
- `.symtab` which points to our code and gives details about how function calls work

## Writing a Minimal ELF Header

Take a look at `elfheader.hex` which contains a basic "baremetal hex" ELF file, and then `elfheader.smallsyms.hex` which goes slightly further in saving space. There are some small changes compared to an ELF file generated by the GNU toolchain:

- We removed the `.riscv.attributes` section. It _is_ useful in the general case to have the architecture of the code alongside the code; in our case, `rv32i`. However, this section is poorly documented and our binaries will tend to be statically compiled kernels where the architecture doesn't really matter - there's no further linking going on.
- We removed the `strtab` section. There's no real need to have a second section since we're forced to have a `shstrtab` for section headers, and everything seems to work fine if we just re-use that.
- We removed a decent amount of padding. The code in the "GNU" ELF was placed at 0x1000 into the file, which is ~4kB of mostly empty space.
- We remove some seemingly pointless entries from the symbol table, leaving just a required null entry and the actual program's entry.

We leave a small amount of padding in the file for future changes but mostly we optimise for small size.

## Using the ELF Header

`elftemplate` is provided as a template for future programs. It must be changed to be useful, since the length of the program is replaced with `XX XX XX XX` in the template. This length occurs in the program header as well as in the `.text` section header.

To use `elftemplate` for a new program, copy it and replace the dummy program lengths with the actual little-endian hex length, and then append the hex program itself. You can add the program with `cat`, since the ELF header intentionally leaves the program at the end of the file. Finally, use our "xxd compiler" to create an ELF file:

```bash
cat elfheader.hex program.hex | sed "s/#.*$//g" | xxd -r -p > program.elf
```

## Notes

[1] We see a call to `load_elf` which ultimately ends up at [`load\_elf\_ram\_sym`](https://github.com/riscv/riscv-qemu/blob/32a1a94dd324d33578dca1dc96d7896a0244d768/hw/core/loader.c#L461) - the ELF parsing logic might be useful to us later so it's noted here, but in any case it's neat to drill down into these things.

[2] The alternative to generating ELF files for both platforms is to patch QEMU's HiFive1-compatible device to support raw binary files, perhaps with a specified offset.

We could for example patch the `load_kernel` function to parse `-kernel "0x20400000:ret1234.bin"` as "place `ret1234.bin` at `0x2040_0000`". It's a judgement call, but it feels like patching QEMU is further away from what we're trying to do than just banging out an ELF header, which is what we'll be doing later.

At the end of the day, one of the tasks involves writing C and the other involves writing hex!

[3] Something that will come into play later is that we can reduce the need to tweak the ELF header by making our programs a standard size.
